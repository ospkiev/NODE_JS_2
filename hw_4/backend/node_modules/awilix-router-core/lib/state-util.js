"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rollUpState = rollUpState;
exports.getStateAndTarget = getStateAndTarget;
exports.addRoute = addRoute;
exports.addBeforeMiddleware = addBeforeMiddleware;
exports.addAfterMiddleware = addAfterMiddleware;
exports.addHttpVerbs = addHttpVerbs;
exports.getOrCreateConfig = getOrCreateConfig;
exports.getState = getState;
exports.setState = setState;
exports.updateState = updateState;
exports.getOrInitStateForDecoratorTarget = getOrInitStateForDecoratorTarget;
exports.createState = createState;
exports.updateConfig = updateConfig;
exports.createRouteConfig = createRouteConfig;
const util_1 = require("./util");
const symbols_1 = require("./symbols");
/**
 * Rolls up state so paths are joined, middleware rolled into
 * the correct order, etc.
 *
 * @param state
 */
function rollUpState(state) {
    const result = new Map();
    state.methods.forEach((method, key) => {
        result.set(key, {
            paths: concatPaths(state.root.paths, method.paths),
            beforeMiddleware: [
                ...state.root.beforeMiddleware,
                ...method.beforeMiddleware,
            ],
            afterMiddleware: [
                ...method.afterMiddleware,
                ...state.root.afterMiddleware,
            ],
            verbs: method.verbs,
        });
    });
    return result;
}
/**
 * Given a decorated class or a controller builder, returns a normalized
 * target + state object. For example, if using the controller builder,
 * we need to use the `target` property. If using decorators, the required
 * value *is* the target.
 *
 * @param src
 * @returns The normalized target + state, or `null` if not applicable.
 */
function getStateAndTarget(src) {
    const state = getState(src);
    if (!state) {
        return null;
    }
    const target = src[symbols_1.IS_CONTROLLER_BUILDER]
        ? src.target
        : src;
    return { target, state };
}
/**
 * Adds a route to the state.
 *
 * @param state
 * @param methodName
 * @param path
 */
function addRoute(state, methodName, path) {
    const config = getOrCreateConfig(state, methodName);
    return updateConfig(state, methodName, {
        paths: (0, util_1.uniq)([...config.paths, path]),
    });
}
/**
 * Adds middleware that runs before the method on the specified config.
 *
 * @param state
 * @param methodName
 * @param middleware
 */
function addBeforeMiddleware(state, methodName, middleware) {
    const config = getOrCreateConfig(state, methodName);
    return updateConfig(state, methodName, {
        beforeMiddleware: addMiddleware(config.beforeMiddleware, middleware),
    });
}
/**
 * Adds middleware that runs after the method on the specified config.
 *
 * @param state
 * @param methodName
 * @param middleware
 */
function addAfterMiddleware(state, methodName, middleware) {
    const config = getOrCreateConfig(state, methodName);
    return updateConfig(state, methodName, {
        afterMiddleware: addMiddleware(config.afterMiddleware, middleware),
    });
}
/**
 * Adds middleware that runs after the method on the specified config.
 *
 * @param state
 * @param methodName
 * @param value
 */
function addHttpVerbs(state, methodName, value) {
    const config = getOrCreateConfig(state, methodName);
    return updateConfig(state, methodName, {
        verbs: (0, util_1.uniq)([...config.verbs, ...value]),
    });
}
/**
 * Gets or creates a method config.
 *
 * @param state
 * @param methodName
 */
function getOrCreateConfig(state, methodName) {
    const config = methodName === null ? state.root : state.methods.get(methodName);
    if (!config) {
        return createRouteConfig();
    }
    return config;
}
/**
 * Gets the config state from the target.
 *
 * @param target
 */
function getState(target) {
    return ((target && (target.prototype ? target.prototype[symbols_1.STATE] : target[symbols_1.STATE])) ||
        null);
}
/**
 * Sets the config state on the target.
 *
 * @param target
 * @param state
 */
function setState(target, state) {
    if (target.prototype) {
        target.prototype[symbols_1.STATE] = state;
    }
    else {
        target[symbols_1.STATE] = state;
    }
    return state;
}
/**
 * Updates the state on the specified target by invoking the callback with the previous state.
 *
 * @param target
 * @param updater
 */
function updateState(target, updater) {
    setState(target, updater(getOrInitStateForDecoratorTarget(target)));
}
/**
 * Gets or initializes the state for a decorated target
 *
 * @param target
 * @param name
 */
function getOrInitStateForDecoratorTarget(target) {
    return getState(target) || createState();
}
/**
 * Creates a new state object.
 */
function createState() {
    const state = {
        root: createRouteConfig(),
        methods: new Map(),
    };
    return state;
}
/**
 * Updates a config on a state, returns the new state.
 *
 * @param state
 * Existing state.
 *
 * @param methodName
 * If null, updates the root config. Else, the method config.
 *
 * @param newConfig
 * Config to shallow-merge in.
 */
function updateConfig(state, methodName, newConfig) {
    const existing = getOrCreateConfig(state, methodName);
    const mergedConfig = {
        ...existing,
        ...newConfig,
    };
    // Root update is simple.
    if (methodName === null) {
        return {
            ...state,
            root: mergedConfig,
        };
    }
    // Filters out the entry we're replacing.
    const filteredEntries = Array.from(state.methods.entries()).filter(([key]) => key !== methodName);
    return {
        ...state,
        methods: new Map([...filteredEntries, [methodName, mergedConfig]]),
    };
}
/**
 * Creates a new route config object.
 */
function createRouteConfig() {
    return {
        paths: [],
        beforeMiddleware: [],
        afterMiddleware: [],
        verbs: [],
    };
}
/**
 * Adds a middleware to the end of the target array.
 *
 * @param targetArray
 * @param value
 */
function addMiddleware(targetArray, value) {
    return Array.isArray(value)
        ? [...targetArray, ...value]
        : [...targetArray, value];
}
/**
 * Concatenates root and method paths so we have one for each combination.
 */
function concatPaths(rootPaths, methodPaths) {
    if (rootPaths.length === 0) {
        return [...methodPaths];
    }
    const result = [];
    rootPaths.forEach((rootPath) => {
        if (methodPaths.length === 0) {
            result.push(rootPath);
        }
        else {
            methodPaths.forEach((methodPath) => {
                result.push(rootPath + methodPath);
            });
        }
    });
    return result;
}
//# sourceMappingURL=state-util.js.map